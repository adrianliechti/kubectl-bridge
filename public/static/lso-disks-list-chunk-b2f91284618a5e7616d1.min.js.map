{"version":3,"sources":["webpack:///./packages/local-storage-operator-plugin/src/constants/disks-list.ts","webpack:///./packages/local-storage-operator-plugin/src/components/disks-list/types.ts","webpack:///./packages/local-storage-operator-plugin/src/components/disks-list/disks-list-page.tsx","webpack:///./packages/local-storage-operator-plugin/src/constants/index.ts","webpack:///./packages/local-storage-operator-plugin/src/utils/index.ts","webpack:///./packages/local-storage-operator-plugin/src/components/local-volume-discovery/request.ts"],"names":["LABEL_SELECTOR","DiskStates","tableColumnClasses","columnClass","getRowProps","obj","id","deviceID","DiskRow","className","path","status","state","type","model","size","string","fstype","DisksList","props","t","loadError","customData","error","loaded","label","Header","title","sortField","transforms","Row","NoDataEmptyMsg","EmptyMsg","virtualize","NodesDisksListPage","ListComponent","lvdRequestError","setError","lvdRequestInProgress","setProgress","subscription","subscriptionLoaded","subscriptionLoadError","kind","fieldSelector","isList","operatorNs","csvName","installedCSV","nodeName","metadata","name","nodeRole","propName","diskFilters","filterGroupName","reducer","disk","items","Available","NotAvailable","Unknown","filter","states","selected","diskState","includes","all","canCreate","hideLabelFilter","textFilter","rowFilters","flatten","resource","data","discoveredDevices","resources","prop","selector","matchLabels","node","variant","lg","isDisabled","isLoading","onClick","makeLocalVolumeDiscoverRequest","ns","nodeNameByHostnameLabel","labels","response","createError","message","DiskType","diskModeDropdownItems","Object","freeze","BLOCK","FILESYSTEM","ZONE_LABELS","DISK_TYPES","SSD","property","HDD","deviceTypeDropdownItems","DISK","PART","MPATH","fsTypeDropdownItems","EXT4","EXT3","XFS","diskTypeDropdownItems","All","diskSizeUnitOptions","Ti","Gi","DISCOVERY_CR_NAME","HOSTNAME_LABEL_KEY","LABEL_OPERATOR","hasNoTaints","spec","taints","getZone","getNodeSelectorTermsIndices","nodeSelectorTerms","selectorIndex","expIndex","forEach","index","matchExpressions","findIndex","exp","key","operator","getNodesByHostNameLabel","nodes","map","updateLocalVolumeDiscovery","lvd","nodeSelector","Error","existingNodes","Set","values","add","patch","op","value","createLocalVolumeDiscovery","toleration","requestData","request","apiVersion","namespace","tolerations","getDiscoveryRequestData"],"mappings":"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","file":"lso-disks-list-chunk-b2f91284618a5e7616d1.min.js","sourcesContent":["export const LABEL_SELECTOR = 'discovery-result-node';\n","import { K8sResourceCommon } from '@console/internal/module/k8s';\nimport { DiskMechanicalProperties } from '../local-volume-set/types';\n\nexport enum DiskStates {\n  Available = 'Available',\n  NotAvailable = 'NotAvailable',\n  Unknown = 'Unknown',\n}\n\nexport type DiskMetadata = {\n  deviceID: string;\n  fstype: string;\n  model: string;\n  path: string;\n  serial: string;\n  size: number;\n  status: {\n    state: keyof typeof DiskStates;\n  };\n  type: string;\n  vendor: string;\n  property: keyof typeof DiskMechanicalProperties;\n};\n\nexport type LocalVolumeDiscoveryResultKind = K8sResourceCommon & {\n  spec: {\n    nodeName: string;\n  };\n  status: {\n    discoveredDevices: DiskMetadata[];\n  };\n};\n","import * as React from 'react';\nimport { Button, EmptyState, EmptyStateVariant } from '@patternfly/react-core';\nimport { sortable } from '@patternfly/react-table';\nimport * as cx from 'classnames';\nimport * as _ from 'lodash';\nimport { useTranslation } from 'react-i18next';\nimport { RowFilter } from '@console/dynamic-plugin-sdk';\nimport {\n  Table,\n  TableProps,\n  TableData,\n  RowFunctionArgs,\n  MultiListPage,\n} from '@console/internal/components/factory';\nimport {\n  FirehoseResourcesResult,\n  humanizeBinaryBytes,\n  Kebab,\n} from '@console/internal/components/utils';\nimport { useK8sWatchResource } from '@console/internal/components/utils/k8s-watch-hook';\nimport { referenceForModel, NodeKind } from '@console/internal/module/k8s';\nimport { SubscriptionKind, SubscriptionModel } from '@console/operator-lifecycle-manager';\nimport { getNamespace, getNodeRole } from '@console/shared/';\nimport { LABEL_SELECTOR } from '../../constants/disks-list';\nimport { LocalVolumeDiscoveryResult } from '../../models';\nimport {\n  updateLocalVolumeDiscovery,\n  createLocalVolumeDiscovery,\n} from '../local-volume-discovery/request';\nimport { DiskMetadata, DiskStates, LocalVolumeDiscoveryResultKind } from './types';\n\nexport const tableColumnClasses = [\n  '',\n  '',\n  cx('pf-m-hidden', 'pf-m-visible-on-xl'),\n  cx('pf-m-hidden', 'pf-m-visible-on-2xl'),\n  cx('pf-m-hidden', 'pf-m-visible-on-lg'),\n  cx('pf-m-hidden', 'pf-m-visible-on-xl'),\n  Kebab.columnClass,\n];\n\nconst getRowProps = (obj) => ({\n  id: obj.deviceID,\n});\n\nconst DiskRow: React.FC<RowFunctionArgs<DiskMetadata>> = ({ obj }) => (\n  <>\n    <TableData className={tableColumnClasses[0]}>{obj.path}</TableData>\n    <TableData className={tableColumnClasses[1]}>{obj.status.state}</TableData>\n    <TableData className={tableColumnClasses[2]}>{obj.type || '-'}</TableData>\n    <TableData className={cx(tableColumnClasses[3], 'co-break-word')}>{obj.model || '-'}</TableData>\n    <TableData className={tableColumnClasses[4]}>\n      {humanizeBinaryBytes(obj.size).string || '-'}\n    </TableData>\n    <TableData className={tableColumnClasses[5]}>{obj.fstype || '-'}</TableData>\n  </>\n);\n\nconst DisksList: React.FC<TableProps> = (props) => {\n  const { t } = useTranslation();\n\n  const diskHeader = () => [\n    {\n      title: t('lso-plugin~Name'),\n      sortField: 'path',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: t('lso-plugin~Disk State'),\n      sortField: 'status.state',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: t('lso-plugin~Type'),\n      sortField: 'type',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: t('lso-plugin~Model'),\n      sortField: 'model',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[3] },\n    },\n    {\n      title: t('lso-plugin~Capacity'),\n      sortField: 'size',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[4] },\n    },\n    {\n      title: t('lso-plugin~Filesystem'),\n      sortField: 'fstype',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[5] },\n    },\n  ];\n\n  return (\n    <Table\n      {...props}\n      loadError={props.customData.error || props.loadError}\n      loaded={props.customData.loaded && props.loaded}\n      label={t('lso-plugin~Disks')}\n      aria-label={t('lso-plugin~Disks List')}\n      Header={diskHeader}\n      Row={DiskRow}\n      NoDataEmptyMsg={props.customData.EmptyMsg} // when no unfilteredData\n      virtualize\n      getRowProps={getRowProps}\n    />\n  );\n};\n\nexport const NodesDisksListPage: React.FC<NodesDisksListPageProps> = ({\n  obj,\n  ListComponent = undefined,\n}) => {\n  const { t } = useTranslation();\n\n  const [lvdRequestError, setError] = React.useState('');\n  const [lvdRequestInProgress, setProgress] = React.useState(false);\n  const [subscription, subscriptionLoaded, subscriptionLoadError] = useK8sWatchResource<\n    SubscriptionKind[]\n  >({\n    kind: referenceForModel(SubscriptionModel),\n    fieldSelector: 'metadata.name=local-storage-operator',\n    isList: true,\n  });\n\n  const operatorNs = getNamespace(subscription[0]);\n  const csvName = subscription?.[0]?.status?.installedCSV;\n  const nodeName = obj.metadata.name;\n  const nodeRole = getNodeRole(obj);\n  const propName = `lvdr-${nodeName}`;\n\n  const makeLocalVolumeDiscoverRequest = async (ns: string) => {\n    const nodeNameByHostnameLabel = obj.metadata?.labels?.['kubernetes.io/hostname'];\n    setProgress(true);\n    try {\n      await updateLocalVolumeDiscovery([nodeNameByHostnameLabel], ns, setError);\n    } catch (error) {\n      if (error?.response?.status === 404) {\n        try {\n          await createLocalVolumeDiscovery([nodeNameByHostnameLabel], ns, setError);\n        } catch (createError) {\n          setError(createError.message);\n          setProgress(false);\n        }\n      } else {\n        setError(error.message);\n        setProgress(false);\n      }\n    }\n  };\n\n  const EmptyMsg = () => (\n    <EmptyState variant={EmptyStateVariant.lg}>\n      <p>{t('lso-plugin~Disks Not Found')}</p>\n      {csvName && operatorNs && nodeRole !== 'control-plane' && (\n        <Button\n          isDisabled={lvdRequestInProgress}\n          isLoading={lvdRequestInProgress}\n          className=\"pf-v5-u-mt-0\"\n          onClick={() => makeLocalVolumeDiscoverRequest(operatorNs)}\n          variant=\"primary\"\n          id=\"yaml-create\"\n          data-test=\"yaml-create\"\n        >\n          {t('lso-plugin~Discover Disks')}\n        </Button>\n      )}\n    </EmptyState>\n  );\n\n  const diskFilters: RowFilter<DiskMetadata>[] = [\n    {\n      type: 'disk-state',\n      filterGroupName: t('lso-plugin~Disk State'),\n      reducer: (disk) => {\n        return disk?.status?.state;\n      },\n      items: [\n        { id: DiskStates.Available, title: t('lso-plugin~Available') },\n        { id: DiskStates.NotAvailable, title: t('lso-plugin~NotAvailable') },\n        { id: DiskStates.Unknown, title: t('lso-plugin~Unknown') },\n      ],\n      filter: (states, disk) => {\n        if (!states || !states.selected || _.isEmpty(states.selected)) {\n          return true;\n        }\n        const diskState = disk?.status.state;\n        return states.selected.includes(diskState) || !_.includes(states.all, diskState);\n      },\n    },\n  ];\n\n  return (\n    <MultiListPage\n      canCreate={false}\n      title={t('lso-plugin~Disks')}\n      hideLabelFilter\n      textFilter=\"node-disk-name\"\n      rowFilters={diskFilters}\n      flatten={(\n        resource: FirehoseResourcesResult<{ [key: string]: LocalVolumeDiscoveryResultKind }>,\n      ) => resource[propName]?.data[0]?.status?.discoveredDevices ?? []}\n      ListComponent={ListComponent ?? DisksList}\n      resources={[\n        {\n          kind: referenceForModel(LocalVolumeDiscoveryResult),\n          prop: propName,\n          selector: { matchLabels: { [LABEL_SELECTOR]: nodeName } },\n        },\n      ]}\n      customData={{\n        node: nodeName,\n        EmptyMsg,\n        error: lvdRequestError || subscriptionLoadError,\n        loaded: subscriptionLoaded,\n      }}\n    />\n  );\n};\n\nexport type NodesDisksListPageProps = {\n  obj: NodeKind;\n  ListComponent: React.ComponentType;\n};\n","import { TFunction } from 'i18next';\nimport { DiskMechanicalProperties } from '../components/local-volume-set/types';\n\nexport enum DiskType {\n  All = 'All',\n  SSD = 'SSD',\n  HDD = 'HDD',\n}\n\nexport const diskModeDropdownItems = Object.freeze({\n  BLOCK: 'Block',\n  FILESYSTEM: 'Filesystem',\n});\n\nexport const ZONE_LABELS = [\n  'topology.kubernetes.io/zone',\n  'failure-domain.beta.kubernetes.io/zone', // deprecated\n];\n\nexport const DISK_TYPES: {\n  [key: string]: {\n    property: keyof typeof DiskMechanicalProperties;\n  };\n} = {\n  [DiskType.SSD]: {\n    property: 'NonRotational',\n  },\n  [DiskType.HDD]: {\n    property: 'Rotational',\n  },\n};\nexport const deviceTypeDropdownItems = Object.freeze({\n  DISK: 'Disk',\n  PART: 'Part',\n  MPATH: 'Mpath',\n});\n\nexport const fsTypeDropdownItems = Object.freeze({\n  EXT4: 'ext4',\n  EXT3: 'ext3',\n  XFS: 'xfs',\n});\n\nexport const diskTypeDropdownItems = (t: TFunction) =>\n  Object.freeze({\n    [DiskType.All]: t('lso-plugin~All'),\n    [DiskType.SSD]: t('lso-plugin~SSD / NVMe'),\n    [DiskType.HDD]: t('lso-plugin~HDD'),\n  });\n\nexport const AUTO_DISCOVER_ERR_MSG = 'Failed to update the Auto Detect Volume!';\n\nexport const diskSizeUnitOptions = {\n  Ti: 'TiB',\n  Gi: 'GiB',\n};\n\nexport const DISCOVERY_CR_NAME = 'auto-discover-devices';\nexport const LOCAL_STORAGE_NAMESPACE = 'openshift-local-storage';\nexport const HOSTNAME_LABEL_KEY = 'kubernetes.io/hostname';\nexport const LABEL_OPERATOR = 'In';\n","import * as _ from 'lodash';\nimport { NodeKind, MatchExpression } from '@console/internal/module/k8s';\nimport { HOSTNAME_LABEL_KEY, LABEL_OPERATOR, ZONE_LABELS } from '../constants';\n\nexport const hasNoTaints = (node: NodeKind): boolean => _.isEmpty(node.spec?.taints);\n\nexport const getZone = (node: NodeKind) =>\n  node.metadata.labels?.[ZONE_LABELS[0]] || node.metadata.labels?.[ZONE_LABELS[1]];\n\nexport const getNodeSelectorTermsIndices = (\n  nodeSelectorTerms: {\n    matchExpressions: MatchExpression[];\n    matchFields?: MatchExpression[];\n  }[] = [],\n) => {\n  let [selectorIndex, expIndex] = [-1, -1];\n\n  nodeSelectorTerms.forEach((selector, index) => {\n    expIndex = selector?.matchExpressions?.findIndex(\n      (exp: MatchExpression) => exp.key === HOSTNAME_LABEL_KEY && exp.operator === LABEL_OPERATOR,\n    );\n    if (expIndex !== -1) {\n      selectorIndex = index;\n    }\n  });\n\n  return [selectorIndex, expIndex];\n};\n\nexport const getNodesByHostNameLabel = (nodes: NodeKind[]): string[] =>\n  nodes.map((node: NodeKind) => node.metadata?.labels?.['kubernetes.io/hostname']);\n","import * as _ from 'lodash';\nimport {\n  apiVersionForModel,\n  K8sResourceCommon,\n  MatchExpression,\n  Toleration,\n  k8sCreate,\n  k8sPatch,\n  k8sGet,\n} from '@console/internal/module/k8s';\nimport { getNodeSelectorTermsIndices } from '@console/local-storage-operator-plugin/src/utils';\nimport { DISCOVERY_CR_NAME, HOSTNAME_LABEL_KEY, LABEL_OPERATOR } from '../../constants';\nimport { LocalVolumeDiscovery } from '../../models';\n\nexport const getDiscoveryRequestData = (\n  nodes: string[],\n  ns: string,\n  toleration?: Toleration,\n): LocalVolumeDiscoveryKind => {\n  const request: LocalVolumeDiscoveryKind = {\n    apiVersion: apiVersionForModel(LocalVolumeDiscovery),\n    kind: LocalVolumeDiscovery.kind,\n    metadata: { name: DISCOVERY_CR_NAME, namespace: ns },\n    spec: {\n      nodeSelector: {\n        nodeSelectorTerms: [\n          {\n            matchExpressions: [\n              {\n                key: HOSTNAME_LABEL_KEY,\n                operator: LABEL_OPERATOR,\n                values: nodes,\n              },\n            ],\n          },\n        ],\n      },\n    },\n  };\n  if (!_.isEmpty(toleration)) request.spec.tolerations = [toleration];\n  return request;\n};\n\nexport const updateLocalVolumeDiscovery = async (nodes, ns, setError) => {\n  const lvd: LocalVolumeDiscoveryKind = await k8sGet(LocalVolumeDiscovery, DISCOVERY_CR_NAME, ns);\n  const nodeSelectorTerms = lvd?.spec?.nodeSelector?.nodeSelectorTerms;\n  const [selectorIndex, expIndex] = getNodeSelectorTermsIndices(nodeSelectorTerms);\n  if (selectorIndex !== -1 && expIndex !== -1) {\n    const existingNodes = new Set(\n      lvd?.spec?.nodeSelector?.nodeSelectorTerms?.[selectorIndex]?.matchExpressions?.[\n        expIndex\n      ]?.values,\n    );\n    nodes.forEach((name) => existingNodes.add(name));\n    const patch = [\n      {\n        op: 'replace',\n        path: `/spec/nodeSelector/nodeSelectorTerms/${selectorIndex}/matchExpressions/${expIndex}/values`,\n        value: [...existingNodes],\n      },\n    ];\n    await k8sPatch(LocalVolumeDiscovery, lvd, patch);\n    setError('');\n  } else {\n    throw new Error(\n      'Could not find matchExpression of type key: \"kubernetes.io/hostname\" and operator: \"In\"',\n    );\n  }\n};\n\nexport const createLocalVolumeDiscovery = async (nodes, ns, toleration?) => {\n  const requestData = getDiscoveryRequestData(nodes, ns, toleration);\n  await k8sCreate(LocalVolumeDiscovery, requestData);\n};\n\nexport type LocalVolumeDiscoveryKind = K8sResourceCommon & {\n  spec: {\n    nodeSelector?: {\n      nodeSelectorTerms: { matchExpressions: MatchExpression[]; matchFields?: MatchExpression[] }[];\n    };\n    tolerations?: Toleration[];\n  };\n};\n"],"sourceRoot":""}